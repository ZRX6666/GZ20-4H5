<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- <script>
        var name = 'nick'
        var age = 17

        var obj = {
            name: 'mark',
            objAge: this.age,
            greet: function () {
                console.log(this.name, this.age)
            }
        }
        obj.greet()
        // 这种用法 greet里面的 this 指向 当前对象 obj
        // this指向 函数运行时所挂载的对象


        function xxx() {
            console.log(this.name)
        }
        // xxx()
        window.xxx()
        // 这种用法 xxx函数 this 指向 当前对象 window 全局对象


        // call()、apply()、bind() 都是用来重定义 this 这个对象的
    </script> -->

    <!-- <script>
        var nick = {
            name: 'Nick',
            age: 17,
            greet: function (param) {
                console.log(this.name, this.age, param)
            }
        }

        // nick.greet()

        var mark = {
            name: 'Mark',
            age: 18
        }
        // mark.greet()
        // call()、apply() 本质上功能 临时借用某个方法

        // func.call([thisArg[, arg1, arg2, ...argN]])
        nick.greet.call(mark, 'test')
        // 把nick对象的greet方法 临时挂载到 mark对象上面来使用
        // 借用的方法里里面的this 指向 mark 借用的这个对象
    </script> -->

    <!-- <script>
        var name = 'nicholas'
        function greet(a, b) {
            console.log(a, b, this.name)
        }
        greet(1, 2)

        var obj = {
            name: 'marry'
        }
        greet.call(obj, 3, 4)

    </script> -->

    <!-- <ul>
        <li>item 1</li>
        <li>item 2</li>
        <li>item 3</li>
        <li>item 4</li>
        <li>item 5</li>
    </ul>
    <script>
        var lisHTML = document.getElementsByTagName('li')
        // lisHTML html集合 类数组 => 没有数组方法 不能使用数组方法 没有 foreach方法

        // html集合不能使用 forEach
        // lisHTML.forEach(function (element) {
        //     console.log(element)
        // });


        // 这里使用最基础的for循环
        // for (var i = 0; i < lisHTML.length; i++) {
        //     console.log(lisHTML[i])
        // }

        // 借用 数组里面的 forEach方法 Array.prototype
        Array.prototype.forEach.call(lisHTML, function (element) {
            console.log('借用的', element)
        })
        // 类数组  html集合 nodelist  classList arguments
        function xxx() {
            // console.log(arguments)

            // arguments 类数组 没有数组方法 不能使用数组方法 
            // Array.prototype.forEach.call(arguments, function (element) {
            //     console.log('arguments对象借用forEach方法', element)
            // })

            var x = Array.prototype.slice.call(arguments)
            console.log(x)
            // 相当于 把类数组转换为 数组  slice返回新数组
        }
        xxx(1, 2, 3, 4, 5)






        console.log('===========')
        var lisNODE = document.querySelectorAll('li')
        // lisNODE 节点列表 类数组 => 没有数组方法 不能使用数组方法 有 foreach方法

        // 节点列表可以使用forEach
        lisNODE.forEach(function (element) {
            console.log(element)
        });

    </script> -->

    <script>
        var nick = {
            name: 'Nick',
            age: 17,
            greet: function (a, b, c) {
                console.log(this.name, this.age, a, b, c)
            }
        }

        nick.greet(1, 2, 3)

        var mark = {
            name: 'Mark',
            age: 18
        }
        nick.greet.call(mark, 4, 5, 6)
        nick.greet.apply(mark, [7, 8, 9])


        var n = nick.greet.bind(mark, 0, 0, 1)
        console.log(n)
        // 返回一个新函数 绑定this指向 锁死指向 this不再是动态指向
        // 参数与call 一致
        n()
        // 这里的n函数 里面的this指向 固定了 mark

        nick.n = n
        nick.n()


        // call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：
        // call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 obj.myFun.call(db,'成都', ... ,'string' )。
        // apply 的所有参数都必须放在一个数组里面传进去 obj.myFun.apply(db,['成都', ..., 'string' ])。
        // bind 除了返回是函数以外，它 的参数和 call 一样。
    </script>
</body>

</html>